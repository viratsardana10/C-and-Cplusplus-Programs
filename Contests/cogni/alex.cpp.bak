#include <iostream>
#include <map>
#include <set>
#include <list>
#include <iterator>
#include <stack>
#include <vector>
using namespace std;

#define INF 99999999

typedef set<string> node_set;
typedef map<string, node_set> Map;
typedef list<string> n_stack;
typedef map<int, vector<int> > Map_scc;
Map node;

int N, R;
string source;

node_set all_nodes;

map<string, int> node_index;
map<string, int> node_lowlink;
list<string> node_stack;

int index;

int scc_count = 0;
vector<node_set> sccs;
Map_scc scc_edge;  // graph of sccs
int scc_source;
list<int> scc_topsort;
int vtime = 0;
struct graph {
	int color;
	int parent;	
	int time1;
	int time2;
	int child;
	int length = 0;
} *scc_node;

void SCC();
void tarjan(string );
void SCC_GRAPH();
void _SCC_SOURCE_();
void _SCC_TOPSORT_();
void visit(int );

int min(int ,int );

int main()
{
	int T;
	cin >> T;
	while(T--) {
		cin >> N >> R;
		
		string s1, s2;
		for(int i = 0 ; i < R; ++i) {
			cin >> s1 >> s2;
			node[s1].insert(s2);		
		}

		cin >> source;
		
		for(Map::iterator iter = node.begin(); iter != node.end(); ++iter)
		{
			all_nodes.insert(iter->first);
			node_index[iter->first] = INF;
			cout << iter->first << " -> ";
			node_set temp = iter->second;
			for(node_set::iterator iter2 = temp.begin(); iter2 != temp.end(); ++iter2)
				cout << *iter2 << " ";
			cout << endl;				
		}		
		SCC();				
		SCC_GRAPH();
		for(Map_scc::iterator iter = scc_edge.begin(); iter != scc_edge.end(); ++iter)
		{
			cout << iter->first << " -> ";
			vector<int> temp = iter->second;
			for(vector<int>::iterator iter2 = temp.begin(); iter2 != temp.end(); ++iter2)
				cout << *iter2 << " ";
			cout << endl;
		}	
		_SCC_SOURCE_();
		cout << "source: " << scc_source << endl;
		cout << "scc_count: " << scc_count << endl;
		scc_node = new struct graph[scc_count];
		_SCC_TOPSORT_();
		for(list<int>::iterator iter = scc_topsort.begin(); iter != scc_topsort.end(); ++iter) {
				cout << *iter << " ";
				int v = *iter;
				vector<int> temp = scc_edge[v];
				int size = temp.size();
				for(int i = 0 ; i < size(); ++i)
				{
					int w = temp[i];
					if (scc_node[w].length <= scc_node[v].length+1 ) {
						scc_node[w].length = scc_node[v].length+1;
						
					}
				}	
		}
		cout << endl;
			
		
	}
	return 0;
}


void SCC()
{
	index = 0;
	for(node_set::iterator iter2 = all_nodes.begin(); iter2 != all_nodes.end(); ++iter2)
	{
		if(node_index[*iter2] == INF)
			tarjan(*iter2);
	}		
}

void tarjan(string v)
{
	node_index[v] = index;
	node_lowlink[v] = index;		
	index += 1;
	node_stack.push_back(v);

	node_set temp = node[v];
	for(node_set::iterator iter2 = temp.begin(); iter2 != temp.end(); ++iter2)
	{	
		string v1 = *iter2;
		if(node_index[v1] == INF)
		{
			tarjan(v1);
			node_lowlink[v] = min(node_lowlink[v], node_lowlink[v1]);
			
		}
		else { 
			bool flag = false;
			for(n_stack::iterator iter3 = node_stack.begin(); iter3 != node_stack.end(); ++iter3)
			{
				if(*iter3 == v1) { flag = true; break; }
			}				
			if(flag)
				node_lowlink[v] = min(node_lowlink[v], node_index[v1]);	
		}
	}
	if(node_lowlink[v] == node_index[v])
	{
		cout << "SCC: ";
		string v1;
		node_set temp;
		do {
			if(!node_stack.empty()) {
				v1 = node_stack.back();
				node_stack.pop_back();
				temp.insert(v1);
				cout << v1 << " ";
			}
		} while(!(v1 == v));
		sccs.push_back(temp);
		++scc_count;
		cout << endl; 
	}	

}

void SCC_GRAPH()
{
	int size = sccs.size();
	for(int i = 0 ; i < size; ++i)
	{
		node_set scc1 = sccs[i];
		for(int j = 0 ; j < i; ++j)
		{	
			bool flag = false;
			node_set scc2 = sccs[j];
			for(node_set::iterator iter1 = scc1.begin(); iter1 != scc1.end(); ++iter1)
			{
				node_set temp = node[*iter1];
				for(node_set::iterator iter2 = scc2.begin(); iter2 != scc2.end(); ++iter2)
				{
					node_set::iterator iter3 = temp.find(*iter2);
					if(iter3 != temp.end()) {
						scc_edge[i].push_back(j);
						flag = true;
						break;
					}
				}
				if(flag) break;
			}	
		}

		for(int j = i+1 ; j < size; ++j)
		{
			bool flag = false;
			node_set scc2 = sccs[j];
			for(node_set::iterator iter1 = scc1.begin(); iter1 != scc1.end(); ++iter1)
			{
				node_set temp = node[*iter1];
				for(node_set::iterator iter2 = scc2.begin(); iter2 != scc2.end(); ++iter2)
				{
					node_set::iterator iter3 = temp.find(*iter2);
					if(iter3 != temp.end()) {
						scc_edge[i].push_back(j);
						flag = true;
						break;
					}
				}
				if(flag) break;
			}	

		}
	}
}


int min(int a,int b)
{
	int m = (a < b) ? a : b;
	return m;
}

void _SCC_SOURCE_()
{
	int size = sccs.size();
	for(int i = 0 ; i < size; ++i)
	{
		node_set scc1 = sccs[i];
		bool flag = false;
		for(node_set::iterator iter1 = scc1.begin(); iter1 != scc1.end(); ++iter1)
		{
			if(*iter1 == source) {
				scc_source = i;
				flag = true;
				break;
			}	
		}
		if(flag) break;
	}
}

void _SCC_TOPSORT_()
{

	for(int i = 0 ; i < scc_count; ++i) {
		scc_node[i].color = 0;
		scc_node[i].parent = -1;
	}
	visit(scc_source);
/*
	for(int i = 0 ; i < scc_count; ++i) {
		if(scc_node[i].color == 0)
			visit(i);
	}		
*/
}

void visit(int u)
{
	scc_node[u].color = 1;
	vtime += 1;
	scc_node[u].time1 = vtime;
	
	vector<int> temp = scc_edge[u];
	int size = temp.size();
	for(int i = 0; i < size; ++i) 
	{
		int v = temp[i];
		if(scc_node[v].color == 0) {
			scc_node[v].parent = u;
			visit(v);
		}
	}	
	
	scc_node[u].color = 2;
	vtime += 1;
	scc_node[u].time2 = vtime;	
	scc_topsort.push_front(u);
}
	

diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/conf/files /home/dpetrou/lottery/sys/conf/files
*** /sys/conf/files	Tue Sep  9 02:58:40 1997
--- /home/dpetrou/lottery/sys/conf/files	Thu Nov 20 00:18:14 1997
***************
*** 57,62 ****
--- 57,63 ----
  kern/kern_ktrace.c	standard
  kern/kern_lkm.c		standard
  kern/kern_lockf.c	standard
+ kern/kern_lottery.c	standard
  kern/kern_malloc.c	standard
  kern/kern_mib.c		standard
  kern/kern_ntptime.c	standard
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/conf/options /home/dpetrou/lottery/sys/conf/options
*** /sys/conf/options	Tue Sep 16 14:36:55 1997
--- /home/dpetrou/lottery/sys/conf/options	Sat Nov  1 22:52:28 1997
***************
*** 3,8 ****
--- 3,11 ----
  # Format:
  # Option name	filename
  
+ # Do we want to replace the BSD scheduler with lottery scheduling? --dpetrou
+ LOTTERY		opt_lottery.h
+ 
  # Miscellaneous options.
  BOUNCE_BUFFERS	opt_bounce.h
  DDB
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/i386/i386/swtch.s /home/dpetrou/lottery/sys/i386/i386/swtch.s
*** /sys/i386/i386/swtch.s	Wed Oct 16 14:37:58 1996
--- /home/dpetrou/lottery/sys/i386/i386/swtch.s	Sun Dec  7 14:30:37 1997
***************
*** 39,45 ****
  #include "apm.h"
  #include "npx.h"
  #include "opt_user_ldt.h"
! 
  #include <sys/rtprio.h>
  
  #include <machine/asmacros.h>
--- 39,46 ----
  #include "apm.h"
  #include "npx.h"
  #include "opt_user_ldt.h"
! #include "opt_lottery.h"
! 	
  #include <sys/rtprio.h>
  
  #include <machine/asmacros.h>
***************
*** 79,85 ****
--- 80,90 ----
   *
   * Call should be made at spl6(), and p->p_stat should be SRUN
   */
+ #ifdef LOTTERY
+ ENTRY(bsd_setrunqueue)
+ #else /* LOTTERY */
  ENTRY(setrunqueue)
+ #endif /* LOTTERY */
  	movl	4(%esp),%eax
  #ifdef DIAGNOSTIC
  	cmpb	$SRUN,P_STAT(%eax)
***************
*** 138,144 ****
--- 143,153 ----
   *
   * Call should be made at spl6().
   */
+ #ifdef LOTTERY
+ ENTRY(bsd_remrq)
+ #else /* LOTTERY */
  ENTRY(remrq)
+ #endif /* LOTTERY */
  	movl	4(%esp),%eax
  	cmpw	$RTP_PRIO_NORMAL,P_RTPRIO_TYPE(%eax) /* normal priority process? */
  	je	rem_nort
***************
*** 249,260 ****
--- 258,277 ----
  idle_loop:
  	cli
  	movb	$1,_intr_nesting_level		/* charge Intr if we leave */
+ 
+ #ifdef LOTTERY
+ 	call	_lott_choose_next_runner
+ 	movl	%eax, %ecx
+ 	cmpl	$0,%ecx
+ 	CROSSJUMP(jne, swtch_com, je)
+ #else /* LOTTERY */
  	cmpl	$0,_whichrtqs			/* real-time queue */
  	CROSSJUMP(jne, sw1a, je)
  	cmpl	$0,_whichqs			/* normal queue */
  	CROSSJUMP(jne, nortqr, je)
  	cmpl	$0,_whichidqs			/* 'idle' queue */
  	CROSSJUMP(jne, idqr, je)
+ #endif /* LOTTERY */
  	movb	$0,_intr_nesting_level		/* charge Idle for this loop */
  	call	_vm_page_zero_idle
  	testl	%eax, %eax
***************
*** 270,275 ****
--- 287,401 ----
  
  CROSSJUMPTARGET(_idle)
  
+ #ifdef LOTTERY
+ /*
+  * cpu_switch(), modified for lottery scheduler
+  */
+ ENTRY(cpu_switch)
+ 	/* switch to new process. first, save context as needed */
+ 	movl	_curproc,%ecx
+ 
+ 	/* if no process to save, don't bother */
+ 	testl	%ecx,%ecx
+ 	je	sw1
+ 
+ 	movl	P_ADDR(%ecx),%ecx
+ 
+ 	movl	(%esp),%eax		/* Hardware registers */
+ 	movl	%eax,PCB_EIP(%ecx)
+ 	movl	%ebx,PCB_EBX(%ecx)
+ 	movl	%esp,PCB_ESP(%ecx)
+ 	movl	%ebp,PCB_EBP(%ecx)
+ 	movl	%esi,PCB_ESI(%ecx)
+ 	movl	%edi,PCB_EDI(%ecx)
+ 
+ #if NNPX > 0
+ 	/* have we used fp, and need a save? */
+ 	mov	_curproc,%eax
+ 	cmp	%eax,_npxproc
+ 	jne	1f
+ 	addl	$PCB_SAVEFPU,%ecx	/* h/w bugs make saving complicated */
+ 	pushl	%ecx
+ 	call	_npxsave		/* do it in a big C function */
+ 	popl	%eax
+ 1:
+ #endif	/* NNPX > 0 */
+ 
+ 	movb	$1,_intr_nesting_level	/* charge Intr, not Sys/Idle */
+ 
+ 	movl	$0,_curproc		/* out of process */
+ 
+ 	/* save is done, now choose a new process or idle */
+ sw1:
+ 	cli
+ 
+ /* Had to move zeroing want_resched before the lottery, since we may call
+    need_resched() from there... */
+ 	
+ 	movl	$0,%eax
+ 	movl	%eax,_want_resched
+ 
+ 	call	_lott_choose_next_runner
+ 	cmpl	$0,%eax
+ 	CROSSJUMP(je, _idle, jne)
+ 	movl	%eax,%ecx
+ 
+ swtch_com:
+ #ifdef	DIAGNOSTIC
+ 	cmpl	%eax,P_WCHAN(%ecx)
+ 	jne	badsw
+ 	cmpb	$SRUN,P_STAT(%ecx)
+ 	jne	badsw
+ #endif
+ 
+ 	movl	%eax,P_BACK(%ecx) 	/* isolate process to run */
+ 	movl	P_ADDR(%ecx),%edx
+ 	movl	PCB_CR3(%edx),%ebx
+ 
+ 	/* switch address space */
+ 	movl	%ebx,%cr3
+ 
+ 	/* restore context */
+ 	movl	PCB_EBX(%edx),%ebx
+ 	movl	PCB_ESP(%edx),%esp
+ 	movl	PCB_EBP(%edx),%ebp
+ 	movl	PCB_ESI(%edx),%esi
+ 	movl	PCB_EDI(%edx),%edi
+ 	movl	PCB_EIP(%edx),%eax
+ 	movl	%eax,(%esp)
+ 
+ 	movl	%edx,_curpcb
+ 	movl	%ecx,_curproc		/* into next process */
+ 	movb	$0,_intr_nesting_level
+ 
+ #ifdef	USER_LDT
+ 	cmpl	$0, PCB_USERLDT(%edx)
+ 	jnz	1f
+ 	movl	__default_ldt,%eax
+ 	cmpl	_currentldt,%eax
+ 	je	2f
+ 	lldt	__default_ldt
+ 	movl	%eax,_currentldt
+ 	jmp	2f
+ 1:	pushl	%edx
+ 	call	_set_user_ldt
+ 	popl	%edx
+ 2:
+ #endif
+ 
+ 	sti
+ 	ret
+ 
+ CROSSJUMPTARGET(idqr)
+ CROSSJUMPTARGET(nortqr)
+ CROSSJUMPTARGET(sw1a)
+ 
+ badsw:
+ 	pushl	$sw0
+ 	call	_panic
+ 
+ sw0:	.asciz	"cpu_switch"
+ #else /* LOTTERY */
  /*
   * cpu_switch()
   */
***************
*** 446,451 ****
--- 572,578 ----
  	call	_panic
  
  sw0:	.asciz	"cpu_switch"
+ #endif /* LOTTERY */
  
  /*
   * savectx(pcb)
Only in /home/dpetrou/lottery/sys/i386/i386: swtch.s.orig
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/i386/i386/trap.c /home/dpetrou/lottery/sys/i386/i386/trap.c
*** /sys/i386/i386/trap.c	Thu Feb 13 02:51:53 1997
--- /home/dpetrou/lottery/sys/i386/i386/trap.c	Mon Dec  8 00:33:13 1997
***************
*** 85,90 ****
--- 85,92 ----
  #include "isa.h"
  #include "npx.h"
  
+ #include <sys/lottery.h> /* lott profiling *** */
+ 
  int (*pmath_emulate) __P((struct trapframe *));
  
  extern void trap __P((struct trapframe frame));
***************
*** 154,160 ****
--- 156,166 ----
  		 * our priority.
  		 */
  		s = splhigh();
+ 		/* *** lott profiling! */
+ 		lott_cycle_counter(1, "ur:setrunqueue", p);
  		setrunqueue(p);
+ 		/* *** lott profiling! */
+ 		lott_cycle_counter(0, "ur:setrunqueue", p);
  		p->p_stats->p_ru.ru_nivcsw++;
  		mi_switch();
  		splx(s);
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/init_main.c /home/dpetrou/lottery/sys/kern/init_main.c
*** /sys/kern/init_main.c	Thu Jul 10 07:48:59 1997
--- /home/dpetrou/lottery/sys/kern/init_main.c	Sun Nov 23 00:40:21 1997
***************
*** 44,49 ****
--- 44,50 ----
  
  #include "opt_rlimit.h"
  #include "opt_devfs.h"
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/filedesc.h>
***************
*** 59,64 ****
--- 60,69 ----
  #include <sys/sysproto.h>
  #include <sys/vmmeter.h>
  
+ #ifdef LOTTERY
+ #include <sys/lottery.h>
+ #endif /* LOTTERY */
+ 
  #include <machine/cpu.h>
  
  #include <vm/vm.h>
***************
*** 432,437 ****
--- 437,445 ----
  	 */
  	proc0.p_stats->p_start = runtime = mono_time = boottime = time;
  	proc0.p_rtime.tv_sec = proc0.p_rtime.tv_usec = 0;
+ #ifdef LOTTERY
+ 	lott_trust_time();
+ #endif
  
  	/*
  	 * Give the ``random'' number generator a thump.
***************
*** 461,466 ****
--- 469,479 ----
  sched_setup(dummy)
  	void *dummy;
  {
+ #ifdef LOTTERY
+ 	lott_init();
+ 	lott_add_proc(0, curproc);
+ #endif /* LOTTERY */
+ 
  	/* Kick off timeout driven events by calling first time. */
  	roundrobin(NULL);
  	schedcpu(NULL);
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_clock.c /home/dpetrou/lottery/sys/kern/kern_clock.c
*** /sys/kern/kern_clock.c	Tue Feb  4 16:03:43 1997
--- /home/dpetrou/lottery/sys/kern/kern_clock.c	Mon Dec 22 03:18:54 1997
***************
*** 57,62 ****
--- 57,63 ----
   *****************************************************************************/
  
  #include "opt_cpu.h"		/* XXX */
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/systm.h>
***************
*** 83,88 ****
--- 84,91 ----
  #include <sys/gmon.h>
  #endif
  
+ #include <sys/lottery.h> /* *** lott profiling! */
+ 
  static void initclocks __P((void *dummy));
  SYSINIT(clocks, SI_SUB_CLOCKS, SI_ORDER_FIRST, initclocks, NULL)
  
***************
*** 1005,1011 ****
--- 1008,1018 ----
  		if (++p->p_estcpu == 0)
  			p->p_estcpu--;
  		if ((p->p_estcpu & 3) == 0) {
+ 		        /* *** lott profiling! */
+ 		        /*lott_cycle_counter(1, "resetpriority", p);*/
  			resetpriority(p);
+ 		        /* *** lott profiling! */
+ 		        /*lott_cycle_counter(0, "resetpriority", p);*/
  			if (p->p_priority >= PUSER)
  				p->p_priority = p->p_usrpri;
  		}
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_exit.c /home/dpetrou/lottery/sys/kern/kern_exit.c
*** /sys/kern/kern_exit.c	Tue Jan 21 11:40:21 1997
--- /home/dpetrou/lottery/sys/kern/kern_exit.c	Sun Nov  2 01:29:00 1997
***************
*** 40,45 ****
--- 40,46 ----
   */
  
  #include "opt_ktrace.h"
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/systm.h>
***************
*** 65,70 ****
--- 66,75 ----
  #include <sys/shm.h>
  #include <sys/sem.h>
  
+ #ifdef LOTTERY
+ #include <sys/lottery.h>
+ #endif /* LOTTERY */
+ 
  #ifdef COMPAT_43
  #include <machine/reg.h>
  #include <machine/psl.h>
***************
*** 244,249 ****
--- 249,258 ----
  	LIST_REMOVE(p, p_list);
  	LIST_INSERT_HEAD(&zombproc, p, p_list);
  	p->p_stat = SZOMB;
+ 
+ #ifdef LOTTERY
+ 	lott_remove_proc(p);
+ #endif /* LOTTERY */
  
  	LIST_REMOVE(p, p_hash);
  
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_fork.c /home/dpetrou/lottery/sys/kern/kern_fork.c
*** /sys/kern/kern_fork.c	Mon Feb 17 05:59:40 1997
--- /home/dpetrou/lottery/sys/kern/kern_fork.c	Sun Nov 23 00:38:42 1997
***************
*** 40,45 ****
--- 40,46 ----
   */
  
  #include "opt_ktrace.h"
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/systm.h>
***************
*** 54,59 ****
--- 55,64 ----
  #include <sys/ktrace.h>
  #include <sys/unistd.h>	
  
+ #ifdef LOTTERY
+ #include <sys/lottery.h>
+ #endif /* LOTTERY */
+ 
  #include <vm/vm.h>
  #include <vm/vm_param.h>
  #include <vm/lock.h>
***************
*** 368,373 ****
--- 373,381 ----
  	 */
  	(void) splhigh();
  	p2->p_stat = SRUN;
+ #ifdef LOTTERY
+ 	lott_add_proc(p1, p2);
+ #endif /* LOTTERY */
  	setrunqueue(p2);
  	(void) spl0();
  
Only in /home/dpetrou/lottery/sys/kern: kern_lottery.c
Only in /home/dpetrou/lottery/sys/kern: kern_lottery.c~
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_prot.c /home/dpetrou/lottery/sys/kern/kern_prot.c
*** /sys/kern/kern_prot.c	Wed Sep  3 02:30:22 1997
--- /home/dpetrou/lottery/sys/kern/kern_prot.c	Sun Nov  9 00:45:38 1997
***************
*** 43,48 ****
--- 43,50 ----
   * System calls related to processes and protection
   */
  
+ #include "opt_lottery.h"
+ 
  #include <sys/param.h>
  #include <sys/acct.h>
  #include <sys/systm.h>
***************
*** 54,59 ****
--- 56,65 ----
  #include <sys/malloc.h>
  #include <sys/unistd.h>
  
+ #ifdef LOTTERY
+ #include <sys/lottery.h>
+ #endif /* LOTTERY */
+ 
  #ifndef _SYS_SYSPROTO_H_
  struct getpid_args {
  	int	dummy;
***************
*** 371,376 ****
--- 377,385 ----
  		if (uid != pc->p_ruid) {
  			(void)chgproccnt(pc->p_ruid, -1);
  			(void)chgproccnt(uid, 1);
+ #ifdef LOTTERY
+ 			lott_setuid(p->p_pid, uid);
+ #endif /* LOTTERY */
  		}
  		/*
  		 * Set real uid
***************
*** 625,630 ****
--- 634,642 ----
  	if (ruid != (uid_t)-1 && pc->p_ruid != ruid) {
  		(void)chgproccnt(pc->p_ruid, -1);
  		(void)chgproccnt(ruid, 1);
+ #ifdef LOTTERY
+ 		lott_setuid(p->p_pid, ruid);
+ #endif /* LOTTERY */
  		pc->p_ruid = ruid;
  		p->p_flag |= P_SUGID;
  	}
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_resource.c /home/dpetrou/lottery/sys/kern/kern_resource.c
*** /sys/kern/kern_resource.c	Sun Dec 22 18:21:21 1996
--- /home/dpetrou/lottery/sys/kern/kern_resource.c	Sun Nov 23 18:08:01 1997
***************
*** 40,45 ****
--- 40,46 ----
   */
  
  #include "opt_rlimit.h"
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/systm.h>
***************
*** 57,62 ****
--- 58,67 ----
  #include <vm/pmap.h>
  #include <vm/vm_map.h>
  
+ #ifdef LOTTERY
+ #include <sys/lottery.h>
+ #endif /* LOTTERY */
+ 
  int	donice __P((struct proc *curp, struct proc *chgp, int n));
  int	dosetrlimit __P((struct proc *p, u_int which, struct rlimit *limp));
  
***************
*** 205,210 ****
--- 210,218 ----
  	if (n < chgp->p_nice && suser(pcred->pc_ucred, &curp->p_acflag))
  		return (EACCES);
  	chgp->p_nice = n;
+ #ifdef LOTTERY
+ 	lott_pseudo_nice(chgp);
+ #endif /* LOTTERY */
  	(void)resetpriority(chgp);
  	return (0);
  }
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/kern_synch.c /home/dpetrou/lottery/sys/kern/kern_synch.c
*** /sys/kern/kern_synch.c	Sun Aug 17 21:38:29 1997
--- /home/dpetrou/lottery/sys/kern/kern_synch.c	Mon Nov 23 02:36:39 1998
***************
*** 40,45 ****
--- 40,46 ----
   */
  
  #include "opt_ktrace.h"
+ #include "opt_lottery.h"
  
  #include <sys/param.h>
  #include <sys/systm.h>
***************
*** 58,63 ****
--- 59,68 ----
  #include <sys/ktrace.h>
  #endif
  
+ /*#ifdef LOTTERY *** for lott profiling! */
+ #include <sys/lottery.h>
+ /*#endif * LOTTERY */
+ 
  #include <machine/cpu.h>
  
  static void rqinit __P((void *));
***************
*** 73,79 ****
  #ifndef DEFAULT_SCHEDULE_QUANTUM
  #define DEFAULT_SCHEDULE_QUANTUM 10
  #endif
! static int quantum = DEFAULT_SCHEDULE_QUANTUM; /* default value */
  
  static int
  sysctl_kern_quantum SYSCTL_HANDLER_ARGS
--- 78,84 ----
  #ifndef DEFAULT_SCHEDULE_QUANTUM
  #define DEFAULT_SCHEDULE_QUANTUM 10
  #endif
! int quantum = DEFAULT_SCHEDULE_QUANTUM; /* default value */
  
  static int
  sysctl_kern_quantum SYSCTL_HANDLER_ARGS
***************
*** 81,86 ****
--- 86,95 ----
  	int error;
  	int new_val = quantum;
  
+ #ifdef LOTTERY
+ 	return 0;
+ #endif /* LOTTERY */
+ 
  	new_val = quantum;
  	error = sysctl_handle_int(oidp, &new_val, 0, req);
  	if (error == 0) {
***************
*** 104,110 ****
  roundrobin(arg)
  	void *arg;
  {
! 
  	need_resched();
  	timeout(roundrobin, NULL, hz / quantum);
  }
--- 113,119 ----
  roundrobin(arg)
  	void *arg;
  {
!         lott_store_rinfo_quantum_expire(); /* lott profiling! *** */
  	need_resched();
  	timeout(roundrobin, NULL, hz / quantum);
  }
***************
*** 207,212 ****
--- 216,222 ----
  	register int s;
  	register unsigned int newcpu;
  
+ 	lott_do_util();
  	wakeup((caddr_t)&lbolt);
  	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
  		/*
***************
*** 215,222 ****
  		 * (remember them?) overflow takes 45 days.
  		 */
  		p->p_swtime++;
! 		if (p->p_stat == SSLEEP || p->p_stat == SSTOP)
  			p->p_slptime++;
  		p->p_pctcpu = (p->p_pctcpu * ccpu) >> FSHIFT;
  		/*
  		 * If the process has slept the entire second,
--- 225,240 ----
  		 * (remember them?) overflow takes 45 days.
  		 */
  		p->p_swtime++;
! 		if (p->p_stat == SSLEEP || p->p_stat == SSTOP) {
  			p->p_slptime++;
+ 
+ 			/* lott util stuff start */
+ 			if(p->p_slptime == WINDOW_SIZE) {
+ 			    lott_sleep_util(p->p_pid);
+ 			}
+ 		}
+ 		/* lott util stuff end */
+ 
  		p->p_pctcpu = (p->p_pctcpu * ccpu) >> FSHIFT;
  		/*
  		 * If the process has slept the entire second,
***************
*** 243,248 ****
--- 261,267 ----
  		resetpriority(p);
  		if (p->p_priority >= PUSER) {
  #define	PPQ	(128 / NQS)		/* priorities per queue */
+ #ifndef LOTTERY
  			if ((p != curproc) &&
  			    p->p_stat == SRUN &&
  			    (p->p_flag & P_INMEM) &&
***************
*** 252,257 ****
--- 271,279 ----
  				setrunqueue(p);
  			} else
  				p->p_priority = p->p_usrpri;
+ #else /* !LOTTERY */
+ 			p->p_priority = p->p_usrpri;
+ #endif /* !LOTTERY */
  		}
  		splx(s);
  	}
***************
*** 323,329 ****
   * call should be interrupted by the signal (return EINTR).
   */
  int
! tsleep(ident, priority, wmesg, timo)
  	void *ident;
  	int priority, timo;
  	char *wmesg;
--- 345,353 ----
   * call should be interrupted by the signal (return EINTR).
   */
  int
! /* dpetrou lottery foo start */
! TSLEEP(ident, priority, wmesg, timo)
! /* dpetrou lottery foo end */
  	void *ident;
  	int priority, timo;
  	char *wmesg;
***************
*** 491,497 ****
  				p->p_slptime = 0;
  				p->p_stat = SRUN;
  				if (p->p_flag & P_INMEM) {
! 					setrunqueue(p);
  					need_resched();
  				} else {
  					p->p_flag |= P_SWAPINREQ;
--- 515,534 ----
  				p->p_slptime = 0;
  				p->p_stat = SRUN;
  				if (p->p_flag & P_INMEM) {
! 					/* *** lott profiling! */
! 				        lott_cycle_counter(1,
! 							   "wk:setrunqueue",
! 							   p);
! 				        setrunqueue(p);
! 					/* *** lott profiling! */
! 					lott_cycle_counter(0,
! 							   "wk:setrunqueue",
! 							   p);
! 					/*
! 					 * Since curpriority is a user pri,
! 					 * p->p_priority is always better than
! 					 * curpriority.  (no priority check...)
! 					 */
  					need_resched();
  				} else {
  					p->p_flag |= P_SWAPINREQ;
***************
*** 536,542 ****
--- 573,592 ----
  				p->p_slptime = 0;
  				p->p_stat = SRUN;
  				if (p->p_flag & P_INMEM) {
+ 					/* *** lott profiling! */
+ 				        lott_cycle_counter(1,
+ 							   "wk2:setrunqueue",
+ 							   p);
  					setrunqueue(p);
+ 					/* *** lott profiling! */
+ 					lott_cycle_counter(0,
+ 							   "wk2:setrunqueue",
+ 							   p);
+ 					/*
+ 					 * Since curpriority is a user pri,
+ 					 * p->p_priority is always better than
+ 					 * curpriority.  (no priority check...)
+ 					 */
  					need_resched();
  					break;
  				} else {
***************
*** 603,608 ****
--- 653,666 ----
  	p->p_rtime.tv_usec = u;
  	p->p_rtime.tv_sec = s;
  
+ #ifdef LOTTERY
+ 	lott_cycle_counter(1, "lott_compensate", p);
+ 	lott_compensate(p, &tv);
+ 	lott_cycle_counter(0, "lott_compensate", p);
+ #else /* LOTTERY */
+ 	lott_store_rinfo_proc(p, &tv); /* *** for lott profiling! */
+ #endif /* LOTTERY */
+ 
  	/*
  	 * Check if the process exceeds its cpu resource allocation.
  	 * If over max, kill it.
***************
*** 624,630 ****
--- 682,690 ----
  	 * Pick a new current process and record its start time.
  	 */
  	cnt.v_swtch++;
+ 	lott_cycle_counter(1, "cpu_switch", p); /* *** lott profiling! */
  	cpu_switch(p);
+ 	lott_cycle_counter(0, "cpu_switch", p); /* *** lott profiling! */
  	microtime(&runtime);
  	splx(x);
  }
***************
*** 674,681 ****
  		break;
  	}
  	p->p_stat = SRUN;
! 	if (p->p_flag & P_INMEM)
  		setrunqueue(p);
  	splx(s);
  	if (p->p_slptime > 1)
  		updatepri(p);
--- 734,746 ----
  		break;
  	}
  	p->p_stat = SRUN;
! 	if (p->p_flag & P_INMEM) {
! 	        /* *** lott profiling! */
! 	        lott_cycle_counter(1, "set:setrunqueue", p);
  		setrunqueue(p);
+ 	        /* *** lott profiling! */
+ 	        lott_cycle_counter(0, "set:setrunqueue", p);
+ 	}
  	splx(s);
  	if (p->p_slptime > 1)
  		updatepri(p);
***************
*** 703,711 ****
  		newpriority = PUSER + p->p_estcpu / 4 + 2 * p->p_nice;
  		newpriority = min(newpriority, MAXPRI);
  		p->p_usrpri = newpriority;
! 		if (newpriority < curpriority)
  			need_resched();
! 	} else {
! 		need_resched();
  	}
  }
--- 768,784 ----
  		newpriority = PUSER + p->p_estcpu / 4 + 2 * p->p_nice;
  		newpriority = min(newpriority, MAXPRI);
  		p->p_usrpri = newpriority;
! 		if (newpriority < curpriority) {
! 		        /* *** lott profiling! */
! 		        lott_cycle_counter(1, "rt:nd_resched", p);
  			need_resched();
! 		        /* *** lott profiling! */
! 		        lott_cycle_counter(0, "rt:nd_resched", p);
! 		}
! 	}
! #ifndef LOTTERY
! 	else {
! 	        need_resched();
  	}
+ #endif /* !LOTTERY */
  }
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/kern/syscalls.master /home/dpetrou/lottery/sys/kern/syscalls.master
*** /sys/kern/syscalls.master	Wed Sep  3 02:31:56 1997
--- /home/dpetrou/lottery/sys/kern/syscalls.master	Tue Jul 14 02:18:02 1998
***************
*** 30,35 ****
--- 30,37 ----
  #include <sys/sysent.h>
  #include <sys/sysproto.h>
  
+ #include "opt_lottery.h"
+ 
  ; Reserved/unimplemented system calls in the range 0-150 inclusive
  ; are reserved for use in future Berkeley releases.
  ; Additional system calls implemented in vendor and other
***************
*** 234,240 ****
  151	UNIMPL	NOHIDE	sem_lock (BSD/OS 2.x)
  152	UNIMPL	NOHIDE	sem_wakeup (BSD/OS 2.x)
  153	UNIMPL	NOHIDE	asyncdaemon (BSD/OS 2.x)
! 154	UNIMPL	NOHIDE	nosys
  #ifdef NFS
  155	STD	BSD	{ int nfssvc(int flag, caddr_t argp); }
  #else
--- 236,243 ----
  151	UNIMPL	NOHIDE	sem_lock (BSD/OS 2.x)
  152	UNIMPL	NOHIDE	sem_wakeup (BSD/OS 2.x)
  153	UNIMPL	NOHIDE	asyncdaemon (BSD/OS 2.x)
! 154	STD	BSD	{ int lott_sched(int which, int a1, int a2, int a3, \
!                             int a4, int a5); }
  #ifdef NFS
  155	STD	BSD	{ int nfssvc(int flag, caddr_t argp); }
  #else
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/sys/kernel.h /home/dpetrou/lottery/sys/sys/kernel.h
*** /sys/sys/kernel.h	Fri Sep 20 10:36:14 1996
--- /home/dpetrou/lottery/sys/sys/kernel.h	Tue Nov  4 18:38:25 1997
***************
*** 72,77 ****
--- 72,79 ----
  extern int tickdelta;
  extern long timedelta;
  
+ extern int quantum; /* lottery sched --dpetrou */
+ 
  /*
   * The following macros are used to declare global sets of objects, which
   * are collected by the linker into a `struct linker_set' as defined below.
Only in /home/dpetrou/lottery/sys/sys: lottery.h
Only in /home/dpetrou/lottery/sys/sys: lottery.h~
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/sys/malloc.h /home/dpetrou/lottery/sys/sys/malloc.h
*** /sys/sys/malloc.h	Tue Aug 20 03:18:05 1996
--- /home/dpetrou/lottery/sys/sys/malloc.h	Sun Nov  2 02:22:27 1997
***************
*** 129,135 ****
  #define	M_BIOBUF	82	/* BIO buffer */
  #define	M_KTRACE	83	/* KTRACE */
  #define	M_SELECT	84	/* select() buffer */
! #define	M_LAST		85	/* Must be last type + 1 */
  
  #define INITKMEMNAMES { \
  	"free",		/* 0 M_FREE */ \
--- 129,136 ----
  #define	M_BIOBUF	82	/* BIO buffer */
  #define	M_KTRACE	83	/* KTRACE */
  #define	M_SELECT	84	/* select() buffer */
! #define M_LOTTERY       85      /* lottery sched (next line too) --dpetrou */
! #define	M_LAST		86	/* Must be last type + 1 */
  
  #define INITKMEMNAMES { \
  	"free",		/* 0 M_FREE */ \
***************
*** 214,220 ****
--- 215,224 ----
  	"BIO buffer",	/* 82 M_BIOBUF */ \
  	"KTRACE",	/* 83 M_KTRACE */ \
  	"select",	/* 84 M_SELECT */ \
+         "LotterySched", /* 85 M_LOTTERY */ \
  }
+ 
+ /* last line above for lottery scheduling --dpetrou *** */
  
  struct kmemstats {
  	long	ks_inuse;	/* # of packets of this type currently in use */
diff -c -r --exclude=compile --exclude=PARTITA* --exclude=init_sysent.c --exclude=syscalls.c --exclude=syscall-hide.h --exclude=syscall.h --exclude=sysproto.h /sys/sys/systm.h /home/dpetrou/lottery/sys/sys/systm.h
*** /sys/sys/systm.h	Sun Aug 10 22:04:12 1997
--- /home/dpetrou/lottery/sys/sys/systm.h	Thu Jul 16 20:51:22 1998
***************
*** 196,202 ****
   * Common `proc' functions are declared here so that proc.h can be included
   * less often.
   */
! int	tsleep __P((void *chan, int pri, char *wmesg, int timo));
  void	wakeup __P((void *chan));
  
  #endif /* !_SYS_SYSTM_H_ */
--- 196,209 ----
   * Common `proc' functions are declared here so that proc.h can be included
   * less often.
   */
! 
! /* dpetrou lottery foo start */
! int	TSLEEP __P((void *chan, int pri, char *wmesg, int timo));
! int lott_store_rinfo_location(void *chan, int pri, char *wmesg, int timo,
! 			      char *file, char *function, int line);
! #define tsleep(chan, pri, wmesg, timo) lott_store_rinfo_location(chan, pri, wmesg, timo, __FILE__, __FUNCTION__, __LINE__)
! /* dpetrou lottery foo end */
! 
  void	wakeup __P((void *chan));
  
  #endif /* !_SYS_SYSTM_H_ */
Only in /home/dpetrou/lottery/sys/: texput.log
